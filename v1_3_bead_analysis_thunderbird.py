# -*- coding: utf-8 -*-
"""V1.3 Bead Analysis Thunderbird.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oonHxXE4rGAbdXpEsbgw-kI98rhG7t9o

Requests:
"""

#@title Fill Out form and Click Play Button { run: "auto" }
#@markdown ---
Running_On_Mac = True #@param {type:"boolean"}
Output_Browser = True #@param {type:"boolean"}
Name = 'MY NAME' #@param {type:"string"}
Run_ID = 'Beads' #@param {type:"string"}
Analysis_Type = 'BEADS_INDV' #@param ["BEADS", "BEADS_INDV"]
#Flourecence_Thresh_G = '' #@param {type:"string"}
#Flourecence_Thresh_B = '' #@param {type:"string"}
#@markdown ---
Input_Directory = '/content/drive/Shareddrives/Microfluidics/a.MicroscopeData/5. Users/Avani/Lubna-cy5.2021-05-11-23-53-48'  #@param {type:"string"}
Output_Folder = '' #@param {type:"string"}
#@markdown ---
Specify_Input_Folders = False #@param {type:"boolean"}
Input_Folders_Separated_By_Commas = ''  #@param {type:"string"}
#@markdown ---

#replace the G: folder if existing  
Input_Directory = Input_Directory.replace("\\", "/").replace("G:/", "")
Output_Folder = Output_Folder.replace("\\", "/").replace("G:/", "")


if ":" in Input_Directory or ":" in Output_Folder:
  print("\n\n########################################################\n\n")
  print("\n\n##############  ERROR: Input_Directory or Output_Folder is not formatted properly  ##############\n\n")
  print("\n\n##############  Please format it like the example (do not keep mount locations in like G:, E:, ect.)  ##############\n\n")
  print("\n\n########################################################\n\n")


#you must have permission to the folder where you are trying to access
print("\n\n########################################################\n\n")
print("\n\n##############  COPY AND PASTE CODE IN LINK BELOW FOR AUTHORIZATION  ##############\n\n")
print("\n\n########################################################\n\n")
from google.colab import drive
drive.mount('/content/drive', force_remount=True)

if Running_On_Mac:
  print("\n\n########################################################\n\n")
  print("\n\n##############  FOR MAC USERS: PLEASE COPY PATH FROM DROPDOWN MENU ON LEFT AND RUN AGAIN  ##############\n\n")
  print("\n\n########################################################\n\n")

#@title Imports and Installs

from datetime import date
import cv2
import csv
from matplotlib import pyplot as plt
import numpy as np
import os
import statistics
import math
import seaborn as sns
import glob
from PIL import Image
from subprocess import check_output
import matplotlib.patches as mpatches
import statistics
from functools import lru_cache as cache
from numpy import inf
import h5py
import pandas as pd
from math import isnan
import seaborn as sns
import glob
from scipy.ndimage import interpolation, gaussian_filter, median_filter, label, labeled_comprehension
from scipy.signal import medfilt,convolve2d
import matplotlib.image as mpimg 
import matplotlib.pyplot as plt 
from scipy.stats import variation 

from matplotlib.colors import ListedColormap
from scipy.ndimage.morphology import grey_dilation

import warnings
warnings.filterwarnings('ignore')

Date = date.today()

#global figure size
fig_size = (10,10)

directories = []

#checks and fixes for input directories
if Input_Directory[-1] != '/':
  Input_Directory += '/'

if Running_On_Mac == True:
  input_dir = Input_Directory
  if Output_Folder:
    output_folder = Output_Folder + "/"
else:
  input_dir = "/content/drive/" + Input_Directory
  if Output_Folder:
    output_folder = "/content/drive/" + Output_Folder + "/"

if Specify_Input_Folders:
  files_specified = Input_Folders_Separated_By_Commas.split(",")
  for file in files_specified:
    specific_folder = input_dir + file
    recursive_files = glob.glob(specific_folder + "/**/", recursive=True)
    for rfile in recursive_files:
      directories.append(rfile)
else:
  directories = glob.glob(input_dir + "**/", recursive=True)
print(directories)
if len(directories) < 1:
  print("\n\n########################################################\n\n")
  print("\n\n##############  BAD FORMATTING OR I CANNOT SEE YOUR FOLDER  ##############\n\n")
  print("\n\n########################################################\n\n")

#@title Detect Functions

#@title Detection Improve
#################################################|##############################
def Circle_Finder_Improve(circles,img):

  #the lower this is the more it removes, max is 1 for no filtering
  FILTER_VALUE = 0.75

  indv_img_shape = (100,100)
  crop_detection_reduce = 45
  accurate_circles = []
  for c in circles[0, :]:
    if c[0] > 125 and c[0] < 2475:
      if c[1] > 125 and c[1] < 1825:
        average = 0
        if c is not None:
          img_copy = img.copy()
          img_clean = img.copy()
          c = c.astype(int)
          crop_bead_increase = c[2]*0.13

          cv2.circle(img_copy, (c[0], c[1]), c[2], (0, 255, 0), 10)

          crop_bead_increase = int(c[2] + crop_bead_increase)
        
          crop = img_copy[c[1]-crop_bead_increase:c[1]+crop_bead_increase, c[0]-crop_bead_increase:c[0]+crop_bead_increase]
          mask = np.zeros(crop.shape)
          mask = cv2.circle(mask, (crop_bead_increase, crop_bead_increase), crop_bead_increase, (255, 255, 255), -1)
          
          final_im = crop/mask
          final_im[final_im == inf] = 0

          crop_c = img_clean[c[1]-crop_bead_increase:c[1]+crop_bead_increase, c[0]-crop_bead_increase:c[0]+crop_bead_increase]
          final_im_c = crop_c/mask
          final_im_c[final_im_c == inf] = 0
          
          if np.count_nonzero(final_im) is not 0:
            final_im = Image_Data_Convert(final_im, 0, 255, np.uint8)  
            hsv = cv2.cvtColor(final_im, cv2.COLOR_BGR2HSV)
            lower_red = np.array([0,200,0])
            upper_red = np.array([255,255,255])
            mask = cv2.inRange(hsv, lower_red, upper_red)
            res = cv2.bitwise_and(final_im_c,final_im_c, mask= mask)
            mean_outline = np.mean(res)
            average = res[np.nonzero(res)].mean()
            decision_img = final_im_c - res
            average_img = decision_img[np.nonzero(decision_img)].mean()
            decision_value = abs(average/average_img)

            if decision_value < FILTER_VALUE:
              accurate_circles.append(list(c))
            else:
              accurate_circles.append([0,0,0])

  return accurate_circles

###############################################################################
def Drops_Color(circles_grey,fluorescent_img):

  indv_img_shape = (100,100)
  crop_detection_reduce = 45
  color_avg_list = []
  for c in circles_grey[0, :]:
    average = 0
    if c is not None:
      img_copy = fluorescent_img.copy()
      img_clean = fluorescent_img.copy()
      c = c.astype(int)
      crop_bead_increase = c[2]*0.0

      cv2.circle(img_copy, (c[0], c[1]), c[2], (0, 255, 0), 10)

      crop_bead_increase = int(c[2] + crop_bead_increase)
    
      crop = img_copy[c[1]-crop_bead_increase:c[1]+crop_bead_increase, c[0]-crop_bead_increase:c[0]+crop_bead_increase]
      mask = np.zeros(crop.shape)
      mask = cv2.circle(mask, (crop_bead_increase, crop_bead_increase), crop_bead_increase, (255, 255, 255), -1)
      
      final_im = crop/mask
      final_im[final_im == inf] = 0

      crop_c = img_clean[c[1]-crop_bead_increase:c[1]+crop_bead_increase, c[0]-crop_bead_increase:c[0]+crop_bead_increase]
      final_im_c = crop_c/mask
      final_im_c[final_im_c == inf] = 0

      color_avg = final_im_c.mean(axis=0).mean(axis=0)
      color_avg_list.append(color_avg)

  return color_avg_list
  
#Look at a random pixel in an image and see what color it is
###############################################################################
def Color_Detection(cd_img: np.array):
  color_detected = "ERROR_Color_Detection"

  if (len(cd_img.shape)<3):
    return 'grey'

  color_avg = cd_img.mean(axis=0).mean(axis=0)
  color_std = round(np.std(color_avg),2)
  color_intensity = np.mean(color_avg)
  intensity_std = color_intensity/color_std

  #Bead Algorithm has different kinds of images
  if intensity_std > 2 or sum(color_avg) > 5:
    offset = intensity_std*1.5
  else:
    offset = 0

  red = color_avg[0]
  green = color_avg[1]
  blue = color_avg[2]

  if color_std == 0:
    color_detected = 'grey'

  elif intensity_std > 5:
    color_detected = 'bf_mixed'

  elif red > green + offset and red > blue + offset:
    color_detected = 'red'

  elif green > red + offset and green > blue + offset:
    color_detected = 'green'

  elif color_std < 15 and color_std > 2:
    color_detected = 'mixed'
    
  elif blue > green + offset and color_avg [2] > red + offset:
    color_detected = 'blue'

  return color_detected

# blur and filter on intensite and detect circle for all but grey images
# grey images runs 3 seperate algorithms to detect the zoom currently being used and to classify it
###############################################################################
def Circle_Finder(img: np.array, color: str) ->list:

  zoom = "na"

  if color == 'green':
    img_g = img
    img_g = cv2.medianBlur(img_g, 5)
    lower_green= np.array([0, 72, 0])
    upper_green = np.array([10, 150, 10])
    mask = cv2.inRange(img_g, lower_green, upper_green)

    circles = cv2.HoughCircles(mask, cv2.HOUGH_GRADIENT, 1, 30, param1=50, param2=12, minRadius=35, maxRadius=60)
    
    #circles format = [[[x,y,radius],[x,y,radius],[x,y,radius]]] 
    return circles, zoom
  
  elif color == 'blue':
    img_b = img
    img_b = cv2.medianBlur(img_b, 5)
    lower_blue= np.array([0, 0, 90])
    upper_blue = np.array([10, 10, 110])
    mask = cv2.inRange(img_b, lower_blue, upper_blue)

    circles = cv2.HoughCircles(mask, cv2.HOUGH_GRADIENT, 1, 30, param1=50, param2=10, minRadius=35, maxRadius=55)
    
    # circles format = [[[x,y,radius],[x,y,radius],[x,y,radius]]]   
    return circles, zoom
  
  #####################
  # adaptive grey circle detector - runs multiple detections and chooses the best
  
  elif color == 'grey':

    zoom = "ERROR"

    if len(img.shape)<3:
      img_bw = img
    else:
      img_bw = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    img_bw = cv2.medianBlur(img_bw, 5)
    
    circles_a = [[0]]
    circles_b = [[0]]
    circles_c = [[0]]

    num_a = 0
    num_b = 0
    num_c = 0

    #HoughCicles is very finicky and will often crash if nothing is found 
    #try:
      #circles_a = cv2.HoughCircles(img_bw, cv2.HOUGH_GRADIENT, 1, 30,param1 = 60, param2 = 30, minRadius = 45, maxRadius = 70)
      #num_a = len(circles_a[0])
    #except:
      #pass
    try:
      circles_b = cv2.HoughCircles(img_bw, cv2.HOUGH_GRADIENT, 1, 30,param1 = 60, param2 = 30, minRadius = 30, maxRadius = 50)
      num_b = len(circles_b[0])
    except:
      pass
    try:
      circles_c = cv2.HoughCircles(img_bw, cv2.HOUGH_GRADIENT, 1, 50,param1 = 35, param2 = 40, minRadius = 70, maxRadius = 120)
      num_c = len(circles_c[0])
    except:
      pass

    #if (num_a > num_b) and (num_a > num_c):
      #circles = circles_a
      #zoom = "med"
    if (num_b > num_a) and (num_b > num_c):
      circles = circles_b
      zoom = "small"
    elif (num_c > num_a) and (num_c > num_b):
      circles = circles_c
      zoom = "large"
    else:
      circles = ["ERROR_ZOOM"]
      zoom = "ERROR"
    #circles format = [[[x,y,radius],[x,y,radius],[x,y,radius]]]  
    return circles, zoom

  elif color == 'ERROR':
    print("ERROR INCORRECT PICTURE TYPE LOADED!")
  else:
    circles = "Something is broken"

  return ["ERROR"], "ERROR"

#run one of 3 blob algorithms based on size 
###############################################################################
def Blob_Detect(im: list, zoom) -> list:

  # Setup SimpleBlobDetector parameters.
  params = cv2.SimpleBlobDetector_Params()

  params.filterByArea = True
  params.filterByCircularity = True
  params.filterByConvexity = True
  params.filterByInertia = False
  params.filterByColor = False
  params.minThreshold = 40
  params.maxThreshold = 225
  params.minCircularity = 0.60
  params.minConvexity = 0.25
  params.minInertiaRatio = 0.00

  if zoom == "small":
    params.minArea = 8000
    params.maxArea = 1000000

  if zoom == "med":
    params.minArea = 15000
    params.maxArea = 10000000

  if zoom == "large":
    params.minArea = 48000
    params.maxArea = 2500000

  # Create a detector with the parameters
  detector = cv2.SimpleBlobDetector_create(params)
  # Detect blobs.
  key_points = detector.detect(im)

  return key_points

#create a mask of the circle outlines and mean those values to determine accuracy of the overlap
#################################################|##############################
def Accuracy_Outline(img_circles, img_clean):

  hsv = cv2.cvtColor(img_circles, cv2.COLOR_BGR2HSV)
  lower_red = np.array([50,50,50])
  upper_red = np.array([255,255,255])
  mask = cv2.inRange(hsv, lower_red, upper_red)
  res = cv2.bitwise_and(img_clean,img_clean, mask= mask)
  mean_outline = np.mean(res)

  return mean_outline


###############################################################################
def get_contours(image):
    c_image = cv2.GaussianBlur(image,(5,5), 0)
    threshold = cv2.threshold(c_image,0,255,cv2.THRESH_BINARY|cv2.THRESH_OTSU)[1]
    contours = cv2.findContours(threshold, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    contours = contours[0] if len(contours) == 2 else contours[1]

    return contours

###############################################################################
def contour_analysis(img, contours, threshold, color, flag = False):
    contour_list = contours
    lst_display = []
    lst_intensities = []
    lst_underthresh = []
    
    for i in range(len(contour_list)):
      # Create a mask image that contains the contour filled in
      cimg = np.zeros_like(img)
      cv2.drawContours(cimg, contour_list, i, color=255, thickness=-1)
      if flag:
        Debug_Image(cimg)
      # Access the image pixels and create a 1D numpy array then add to list
      pts = np.where(cimg == 255)
      avg = sum(img[pts[0], pts[1]]) / len(img[pts[0], pts[1]])
      lst_display.append(avg)
      if avg >= threshold:
        lst_intensities.append(avg)
      else:
        contour_list[i] = None



    return contour_list, lst_intensities,lst_display

###############################################################################
def Flour_Blob(image, color, threshold=0):
    #if image is not grey
    if len(image.shape)==3:
      image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY) 

    rough_contour_list = get_contours(image)
    pruned_contour_list, intensity_list,lst_display = contour_analysis(image, rough_contour_list, threshold, color)
    mask = np.zeros(image.shape, dtype=np.uint8)
    blobs = 0
    for c in pruned_contour_list:
        if c is None:
          continue
        area = cv2.contourArea(c)
        cv2.drawContours(mask, [c], -1, (36,255,12), cv2.FILLED)
        if area > 99: 
          blobs += 1
    bins = 15

    return mask, blobs, intensity_list,lst_display

#@title Bead Counting Algorithm
###############################################################################
def Bead_Counting(circles, img):

  bead_count = 0
  nobead_count = 0
  indv_img_shape = (100,100)
  crop_detection_reduce = 45
  img_copy = img.copy()
  img_list = []
  circles_with_beads = [False] * len(circles)

  circles = np.uint16(np.around(circles))

  for c in circles:
    c = c.astype(int)
    crop_bead_reduce = c[2]*0.1
    c[2] = c[2] - crop_bead_reduce
    crop = img_copy[c[1]-c[2]:c[1]+c[2], c[0]-c[2]:c[0]+c[2]]
    mask = np.zeros(crop.shape)
    mask = cv2.circle(mask, (c[2], c[2]), c[2], (255, 255, 255), -1)

    final_im = crop/mask

    final_im[final_im == inf] = 0
    img_list.append(final_im)

  i = 0
  for img in img_list[0:]:
    if img is not None:     
      shape = img.shape[0:2]
      if shape[0] == shape[1] and shape[0] != 0:
    
        img = Image_Data_Convert(img, 0, 255, np.uint8)    
        resized_img = Change_Image_Size(indv_img_shape,img)
        resized_img = Image_Data_Convert(resized_img, 0, 255, np.uint8)  

        if np.mean(img) > 200:
          normed_img = Brightfield_Norm(resized_img,indv_img_shape)
        else:
          normed_img = resized_img
        
        indv_copy = normed_img.copy()

        normed_img_new = normed_img.astype(np.uint8)
        normed_img_new = cv2.cvtColor(normed_img_new, cv2.COLOR_BGR2GRAY)
        thresholded = cv2.adaptiveThreshold(normed_img_new,255,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY,11,2)
        mean_blur = cv2.medianBlur(thresholded, 5)
        mean_blur = cv2.bitwise_not(mean_blur)

        kernel = np.ones((2,2), np.uint8)
        erosion = cv2.erode(mean_blur,kernel,iterations = 1)
        dialation = cv2.dilate(erosion, kernel, iterations=1) 

        mask = np.zeros(dialation.shape)
        mask = cv2.circle(mask, (50, 50), crop_detection_reduce, (50, 50, 50), -1)
        mask = Image_Data_Convert(mask, 0, 255, np.uint8) 
        bitwise_and_img = cv2.bitwise_and(dialation, mask, mask = None) 

        circles = cv2.HoughCircles(bitwise_and_img, cv2.HOUGH_GRADIENT, 1, 30,param1 = 12, param2 = 12, minRadius = 25, maxRadius = 60)

        if circles is not None:
          circles_with_beads[i] = True
          bead_count += 1  
        else:
          nobead_count += 1

    i += 1
  return bead_count, nobead_count, circles_with_beads

#@title Analyze Functions

###############################################################################
def Analytics_Display(circles, kp_read,zoom):
  radius_list = []
  for c in circles:
    radius_list.append(c[2])

  larger_med = []
  area_list = []
  for radi in radius_list:
    area = 3.14*radi**2
    if area > 1000:
      area_list.append(area)
  number = len(area_list)
  median = statistics.median(area_list)

  avg_r = round(Average_Radius(circles),2)
  std_r = round(STD_Radius(radius_list),2)
  area_std = round(np.std(area_list),2)
  
  if area_std < 700:
    median_factor = 2
    blob_factor = 1.8
  elif area_std > 1000:
    median_factor = 1.35
    blob_factor = 2
  else:
    median_factor = 1.55
    blob_factor = 1.9

  for area in area_list:
    if area > median_factor*median:
      larger_med.append(area)

  arealargermedia = sum(larger_med)
  areatotal = int(sum(area_list))

  num_blobs = len(kp_read)
  
  if zoom == "large":
    factor = .0225
  elif zoom == 'small':
    factor = .15
  else:
    factor = .5

  if num_blobs > 0:
    volume_mergers = [item[0]**blob_factor for item in kp_read]
  else:
    volume_mergers = [0]
  Num2xMed =  len(larger_med) + num_blobs
  Area2xMed = int(arealargermedia) + int(sum(volume_mergers))
  lessthan = 0
  for i in volume_mergers:
    if i > 1000:
      lessthan += i
  Area2xMedless10000 = Area2xMed - int(lessthan)
  emulsion_stability = round((Area2xMed/areatotal)*100)

  return_data = (['Brightfield', int(median*factor), int(area_std*factor), Num2xMed, Area2xMed, areatotal, emulsion_stability, "", "", number])

  #Display outputs for browser viewing
  #####################
  #Significant speed up if not performed
  if Output_Browser:
    print("\nTotal Drops: " + str(number))
    print("AVG Size: " + str(avg_r))
    print("STD: " + str(std_r))
    print("\n")
    print(" - MERGER DROP DETECTION - ")
    print("\n") 

    print("Number of Large Mergers: " + str(num_blobs))

    print("Area of mergers found: " + str(volume_mergers))
    

    print("Emulsions Stability; " + str(emulsion_stability))
    print("Number Blobs and Drops: " + str(num_blobs+number))

  #####################


  return return_data
  
###############################################################################
def Average_Radius(circles: list) -> float:

  sum_radius = 0
  for i in circles:
    sum_radius = i[2] + sum_radius

  return sum_radius/len(circles)

###############################################################################
def STD_Radius(radius_list: list) -> float:

  std = np.std(radius_list)

  return std

###############################################################################
def Sort_Circle(circles: list, selection: str) -> list:
  
  if selection == 'x':
    circles = circles[circles[:,0].argsort()]
  if selection == 'y':
    circles = circles[circles[:,1].argsort()]
  if selection == 'r':
    circles = circles[circles[:,2].argsort()]

  return circles

###############################################################################
class MSImage():
    """Lightweight wrapper for handling image to matrix transforms. No setters,
    main point of class is to remember image dimensions despite transforms."""
    
    def __init__(self, img):
        """Assume color channel interleave that holds true for this set."""
        self.img = img
        self.dims = np.shape(img)
        self.mat = np.reshape(img, (self.dims[0] * self.dims[1], self.dims[2]))

    @property
    def matrix(self):
        return self.mat
        
    @property
    def image(self):
        return self.img
    
    def to_flat_img(self, derived):
        """"Use dims property to reshape a derived matrix back into image form when
        derived image would only have one band."""
        return np.reshape(derived, (self.dims[0], self.dims[1]))
    
    def to_matched_img(self, derived):
        """"Use dims property to reshape a derived matrix back into image form."""
        return np.reshape(derived, (self.dims[0], self.dims[1], self.dims[2]))

###############################################################################
def BNormalize(mat):
    """much faster brightness normalization, since it's all vectorized"""
    bnorm = np.zeros_like(mat, dtype=np.float32)
    maxes = np.max(mat, axis=1)
    bnorm = mat / np.vstack((maxes, maxes, maxes)).T
    return bnorm

#@title Visualization Functions

###############################################################################
def Radius_Histogram(circles_grey, circles_blue = 'na', circles_green = 'na'):
  plt.figure(figsize=fig_size)
  if circles_blue == 'na':
    r_bw = circles_grey[:, [2]]
    sns.distplot(r_bw, rug=True, rug_kws={"color": "k"},
                    kde_kws={"color": "k", "lw": 4, "label": "Grey"},
                    hist_kws={"histtype": "step", "linewidth": .1,
                              "alpha": 1, "color": "k"})

  else:
    r_b = circles_blue[:, [2]]
    r_g = circles_green[:, [2]]

    sns.distplot(r_b, rug=False, rug_kws={"color": "b"},
                      kde_kws={"color": "b", "lw": 2, "label": "Blue"},
                      hist_kws={"histtype": "step", "linewidth": .1,
                                "alpha": 1, "color": "b"})
    sns.distplot(r_g, rug=False, rug_kws={"color": "g"},
                      kde_kws={"color": "g", "lw": 2, "label": "Green"},
                      hist_kws={"histtype": "step", "linewidth": .1,
                                "alpha": 1, "color": "g"})
    r_bw = circles_grey[:, [2]]
    sns.distplot(r_bw, rug=True, rug_kws={"color": "k"},
                    kde_kws={"color": "k", "lw": 4, "label": "Grey"},
                    hist_kws={"histtype": "step", "linewidth": .1,
                              "alpha": 1, "color": "k"})

  plt.show()

#Plot detected drops to visually determine skew of 3 images
###############################################################################
def Scatter_Images(circles_grey, circles_blue, circles_green):
  plt.figure(figsize=fig_size)
  color_bw = "grey"
  x_bw = circles_grey[:, [1]]
  y_bw = circles_grey[:, [0]]
  r_bw = circles_grey[:, [2]]

  color_b = "blue"
  x_b = circles_blue[:, [1]]
  y_b = circles_blue[:, [0]]
  r_b = circles_blue[:, [2]]

  color_g = 'green'
  x_g = circles_green[:, [1]]
  y_g = circles_green[:, [0]]
  r_g = circles_green[:, [2]]

  plt.scatter(x_bw, y_bw, s=r_bw, c=color_bw, alpha=0.7)
  plt.scatter(x_b, y_b, s=r_b, c=color_b, alpha=0.5)
  plt.scatter(x_g, y_g, s=r_g, c=color_g, alpha=0.5)

  plt.title('Image Skew Plot')
  plt.xlabel('Pixels X')
  plt.ylabel('Pixels Y')

  plt.show()

###############################################################################
def Draw_Blobs(image: list, key_points: list) -> list:
    # cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS ensures the size of the circle corresponds to the size of blob
    im_with_key_points = cv2.drawKeypoints(image,
                                          key_points,
                                          np.array([]),
                                          (0, 255, 0),
                                          cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)

    return im_with_key_points

###############################################################################
def Draw_Circles(image: list, circles: list, circles_with_beads) -> list:
    j = 0
    for i in circles:
      if len(circles_with_beads) > 0:
        if circles_with_beads[j]:
          cv2.circle(image, (i[0], i[1]), i[2], (0, 0, 255), 5)
        else:
          cv2.circle(image, (i[0], i[1]), i[2], (255, 0, 0), 5)
        j+=1
      else:
        cv2.circle(image, (i[0], i[1]), i[2], (255, 0, 0), 5)
    return image

###############################################################################
def Draw_Circles_Inverse(image: list, circles: list) -> list:
    for i in circles[0, :]:
      cv2.circle(image, (i[0], i[1]), i[2], (255, 0, 0), -1)
    
    return image

#########################################################################  
def FluorescenceNormalize(blue, bw, green):

  # Make the images of uniform size
  image4 = changeImageSize(2560, 1920, blue)
  image5 = changeImageSize(2560, 1920, green)

  # alpha-blend the images with varying values of alpha
  alphaBlended2 = Image.blend(image4, image5, alpha=.5)

  msifirst = MSImage(alphaBlended2)

  bnorm1 = BNormalize(msifirst.matrix)
  bnorm_img1 = msifirst.to_matched_img(bnorm1)
  plt.figure(figsize=fig_size)
  plt.imshow(bnorm_img1)
  plt.show()
  return bnorm_img1

###############################################################################
def Histogram_Grey(img_bw):

    plt.hist(img_bw.ravel(), 100, [20, 200], density=True, alpha=0.3, color="black")
    
    # Add labels
    plt.title('Drop Histogram')
    plt.xlabel('Brightness')
    plt.ylabel('Percentage of Color')

    no_fluor = mpatches.Patch(alpha = 0.3, color='black', label='No Florescence')

    plt.legend(handles=[no_fluor])
    plt.figure(figsize=fig_size)
    plt.show()

######################################################################################
def Display_Pictures(print_pictures, range_list, name_list):
    range_list = Check_Size(print_pictures, range_list)

    size_wanted = range_list[1]-range_list[0]

    if size_wanted != 0:
        columns = int(math.sqrt(size_wanted))
        row = math.ceil(size_wanted / columns)

        j = 0
        plt.figure(figsize=(30,5))
        for i in range(10000)[range_list[0]:range_list[1]]:
            plt.subplot(columns, row, j + 1), plt.imshow(print_pictures[i], 'gray')
            plt.title(name_list[i])
            plt.xticks([]), plt.yticks([])
            j += 1
        plt.show()

#@title Tools
###############################################################################
def Write_CSV(*args,custom_name): #For each column, pass a list where the first entry is the column's name.
  
  if custom_name:
    filename = output_folder + "/"+ str(Date) + "_" + custom_name + "_"
  else:
    filename = output_folder + "/"+ str(Date) + "_" + Run_ID + "_"
  
  i = 0
  while os.path.exists(f"{filename}{i}.csv"):
    i += 1
  try: 
    rows = zip(*args)
    with open(f"{filename}{i}.csv", 'w') as output:
      writer = csv.writer(output, dialect='excel')  #DictWriter can also be used if you pass in a dictionary with column name, row name for all entries.
      for row in rows:
        writer.writerow(row[0])
  except:
    print("\n\nTHERE IS A PROBLEM IN YOUR DIRECTORY, CHECK THAT YOU HAVE PERMISSION FOR ACCESS")

###############################################################################
def all_imgs_directory(directory):
  image_list = []
  filenames = []
  print("Reading in Images..")
  for filename in glob.glob(directory + '/*.jpg'):
    if 'Analyzed' not in filename:
      im=Image.open(filename)
      filenames.append(filename)
      image_list.append(im)
  for filename in glob.glob(directory + '/*.PNG'):
    if 'Analyzed' not in filename:
      im=Image.open(filename)
      filenames.append(filename)
      im = im.convert('RGB')
      image_list.append(im)
  for filename in glob.glob(directory + '/*.JPG'):
    if 'Analyzed' not in filename:
      im=Image.open(filename)
      filenames.append(filename)
      im = im.convert('RGB')
      image_list.append(im)
  
  return image_list,filenames
  
###############################################################################
def Resize_Img_Grey(image):

  if (image.shape[0] == 960) or (image.shape[1] == 960):

    scale_percent = 200

    width = int(image.shape[1] * scale_percent / 100)
    height = int(image.shape[0] * scale_percent / 100)

    dimensions = (width, height)
    image_resize = cv2.resize(image, dimensions)
    
    return image_resize

  elif (image.shape[0] == 1920) or (image.shape[1] == 1920):
    return image
  
  else:
    scale_percent = 125

    width = int(image.shape[1] * scale_percent / 100)
    height = int(image.shape[0] * scale_percent / 100)

    dimensions = (width, height)
    image_resize = cv2.resize(image, dimensions)
    
    return image_resize 

###############################################################################
def Readable_Key_Points(key_points: list) -> list:
    readable_keypoint = []

    for x in range(len(key_points)):
        readable_keypoint.append(
            [round(key_points[x].size, 2), round(key_points[x].pt[0], 2), round(key_points[x].pt[1], 2)])
    return readable_keypoint

######################################################################################
def Brightfield_Norm(img,size):
  norm_img = np.zeros(size)
  normalized_img = cv2.normalize(img,  norm_img, 70, 255, cv2.NORM_MINMAX)
  if size == (1920,2560):
    avg_pixel = np.mean(normalized_img)
    if avg_pixel < 180:
      normalized_img = cv2.normalize(img,  norm_img, 70, 300, cv2.NORM_MINMAX)
  return normalized_img

######################################################################################
def Incoming_Image_Processing(img):
  resized_img = Resize_Img_Grey(img)
  normalized_img = Brightfield_Norm(resized_img,(1920,2560))
  
  processed_img = normalized_img
  return processed_img
  
######################################################################################
def Debug_Image(img, data_bool = False):

  if data_bool:
    try:
      print("Array: " + str(img))
    except:
      print("Array Fail")
    try:
      print("Shape: " + str(img.shape))
    except:
      print("Shape Fail")
    try:
      print("Dtype: " + str(img.dtype))
    except:
      print("Dtype Fail")
    try:
      print("Mean: " + str(np.mean(img)))
    except:
      print("Mean Fail")
  try:
    plt.figure(figsize=fig_size)
    plt.imshow(img)
    plt.show()
  except:
    print("Display Img Failed")
###############################################################################
# Function to change the image size
def Change_Image_Size(shape, 
                    image):
    maxWidth = shape[0]
    maxHeight = shape[1]
    #convert a numpy array over to a PIL  image
    #https://stackoverflow.com/questions/10965417/how-to-convert-a-numpy-array-to-pil-image-applying-matplotlib-colormap
    image = Image.fromarray(image.astype('uint8'), 'RGB')

    widthRatio  = maxWidth/image.size[0]
    heightRatio = maxHeight/image.size[1]

    newWidth    = int(widthRatio*image.size[0])
    newHeight   = int(heightRatio*image.size[1])

    img    = image.resize((newWidth, newHeight))
    newImage = np.array(img.getdata()).reshape(img.size[0], img.size[1], 3)
    return newImage

###############################################################################
def Image_Data_Convert(img, target_type_min, target_type_max, target_type):
    imin = img.min()
    imax = img.max()

    a = (target_type_max - target_type_min) / (imax - imin)
    b = target_type_max - a * imax
    new_img = (a * img + b).astype(target_type)
    return new_img

###############################################################################
def Channel_Split(image):
    r_img = image[:, :, 0]
    g_img = image[:, :, 1]
    b_img = image[:, :, 2]

    return r_img, g_img, b_img

######################################################################################
def Check_Size(data, range_list):
    if range_list[1] != 0 and len(data) < range_list[1]:
        range_list[1] = len(data)
    return range_list

#@title Beads Analysis

SCATTER_THRESH = .4     # Position of threshold between min and max of scatter
MAX_COLOR      = .99    # Place maximum on fluorescence intensity above this quantile
CONVERSION_4X  = 1.54   # Microscope conversion for 4X objective (um/pix)
CONVERSION_10X = 0.625  # Microscope conversion for 10X objective (um/pix)
DROP_BORDER    = -8     # Pixels added to drop border radius to get full drop extent
MIN_DIAM       = 54     # Minimum drop diameter in microns
MIN_DIAM_PERIM = .15    # Minimum diameter to perimeter ratio (~eccentricity). For circle, diam/perim = 1/pi = 0.32
VALID_COLORS   = ['RGB','BF','DAPI','GFP','RFP','CY5'] # Colors that can be loaded from files
VALID_FLUOR    = ['BF','DAPI','GFP','RFP','CY5']       # Fluorescence channels that can be displayed

###############################################################################
def Beads_Controller(dire):
  return_list = []
  #format: [[set1_identity, [[img1,color,name],[img2,color,name],[img3,color,name]]], [set2_identity, [[img1,color,name],[img2,color,name],[img3,color,name]]]]
  identifier_and_images = Flourecence_Image_Reader(dire)
  if identifier_and_images != []:
    data = Read_Decide_Analyze(identifier_and_images,dire)
  else:
    print("\nNothing in this folder: " + dire)

  #return CSV_DATA

###############################################################################
def load_images(dirpath='',**kwargs):
    ''' 
    Loads and normalizes a single set of fluorescent/bright-field image files into variable.
    If 'RBG' argument is given, all data is taken from that image.
    If not, at least 'BF' argument is necessary.
    
    Parameters:
    -----------
    dirpath: string
        Path with directory image(s) to be analyzed
        
    **kwargs: dictionary
        Filename(s) of images to be loaded.
        Arguments should be from set of VALID_COLORS ('RGB','BF','DAPI','GFP'...)
        
    Returns:
    -----------
    imgs: dictionary
        Collection of each fluorescent/BF image as items with keys from VALID_COLORS
        Images are 2D and normalized from 0-1, except for RGB.
        
    '''
    
    global BW_THRESHOLD, MAX_COLOR
    
    imgs = {}

    # Throw error if no BF data available
    if ('BF' not in kwargs.keys()) & ('RGB' not in kwargs.keys()):
        raise NameError('Need BF or RGB argument.')
    
    # Load images from single 'RGB' file
    if 'RGB' in kwargs.keys():
        img = mpimg.imread(dirpath+kwargs['RGB'])*1.0

        imgs['RGB']  = img
        imgs['BF']   = img[:,:,0]
        imgs['GFP']  = img[:,:,1]-img[:,:,0]
        imgs['DAPI'] = img[:,:,2]-img[:,:,0]
        
    # Otherwise load images individually
    else:
        for color in kwargs.keys():    
            if color in VALID_COLORS:
                imgs[color] = mpimg.imread(dirpath+kwargs[color])   
     
    # Normalize images. Exclude extreme bright points, and scale to 0-1
    for color in imgs.keys():
        if color in VALID_FLUOR:
            color_img = imgs[color].copy()
            mx = np.quantile( color_img, MAX_COLOR)
            color_img[ color_img > mx ] = mx
            color_img [ color_img < 0 ] = 0
            imgs[color] = color_img/mx
            if len(imgs[color].shape) == 3:
              imgs[color] = Image_Data_Convert(imgs[color], 0, 255, np.uint8)
              imgs[color] = cv2.cvtColor(imgs[color], cv2.COLOR_BGR2GRAY)
            
    mn = np.quantile(imgs['BF'],.05)
    imgs['BF'][imgs['BF']<mn] = mn
    
    return imgs

###############################################################################
def find_drops(imgs,invert = False):
    ''' 
    Generates a list of drops and their properties from the 'BF' image.
    
    Parameters:
    -----------
    imgs: dictionary
        Collection of each fluorescent/BF image as items with keys from VALID_COLORS
        
    Returns:
    -----------
    drops: dictionary
        Collection of 1D arrays (each length N, where N is # of drops) associated with drop metrics.
        BF, DAPI, GFP, RFP, CY5 - mean image value inside drop (RFU)
        Diameter  - Diameter in microns
        perimeter - Perimenter in microns
        good      - Boolean, whether the drop is large and round enough
        
    '''
   
    global CONVERSION_4X, MIN_DIAM_PERIM, MIN_DIAM, DROP_BORDER, SCATTER_THRESH
    
    drops={}
    
    #Beads have a white border and dark interior, invert them to be more similar to bead images
    if invert:
      imgs['BF'] = np.invert(imgs['BF'])  

    # Convert BF to BW image using threshold at the mean of the 10th quanth and 50th quantile
    imgs['BW'] = imgs['BF']>np.mean(np.quantile(imgs['BF'],[.075]))

    # Label drops
    lbl,nlbl = label(imgs['BW'])
    lbls = np.arange(1,nlbl+1)

    # Expand boundaries
    lbl = grey_dilation(lbl, size=(3,3))
    # Calculate drop values for each color
    for color in imgs.keys():
        if color in VALID_FLUOR:
            empty_image_check = np.mean(imgs[color])
            if empty_image_check < 200 and empty_image_check > 2:
              drops[color] = labeled_comprehension(imgs[color], lbl, lbls, np.mean, float, 0)
              if 'RGB' in imgs.keys():
                  drops[color] = drops[color] - drops['BF']
            else:
              break
              drops = {}
    if drops != {}:
      # Find drop edges by dilating and keeping borders (to determine perimeter)
      c = convolve2d(imgs['BW'],np.ones((3,3))/9)
      c = np.logical_and(c>.5,c<1)
      lbl_borders = np.multiply(c[1:-1,1:-1],lbl)
                  
      # Find area and perimeter
      pixel_area         = labeled_comprehension(imgs['BW']>-1, lbl, lbls, np.sum, float, 0)
      drops['Radius']  = np.sqrt(pixel_area/np.pi)
      drops['Diameter']  = (np.sqrt(pixel_area/np.pi)*2-DROP_BORDER) * CONVERSION_10X
      drops['perimeter'] = labeled_comprehension(imgs['BW']>-1, lbl_borders , lbls, np.sum, float, 0) * CONVERSION_10X

      mx,my = np.meshgrid(np.arange(imgs['BW'].shape[1]),np.arange(imgs['BW'].shape[0]))
      drops['X']         = labeled_comprehension(mx, lbl , lbls, np.mean, float, 0)
      drops['Y']         = labeled_comprehension(my, lbl , lbls, np.mean, float, 0)

      # Exclude regions with small area-perimeter ratios (high eccentricity) or small areas
      good = (np.divide(drops['Diameter'],drops['perimeter']+20)>MIN_DIAM_PERIM) & (drops['Diameter']>MIN_DIAM)
      drops['good'] = good
      
      # Generate a BW mask of only good drops
      lbl = lbl.flatten()
      lbl = np.isin(lbl,np.where(drops['good'])[0]+1)
      imgs['BW'] = lbl.reshape(imgs['BW'].shape[0],imgs['BW'].shape[1])      

      # Generate histogram data and thresholds
      drops['hists'] = []
      drops['bins'] = []

      colors = np.sort(list(drops.keys()))
      colors = np.insert(colors[colors!='Diameter'],0,'Diameter')
      colors = [c for c in colors if c in ['DAPI','GFP','RFP','CY5','Diameter']]
      nc = len([c for c in colors if c in ['DAPI','GFP','RFP','CY5','Diameter']])

      drops['colors'] = colors
      drops['color_thresh'] = np.zeros(nc)
            
      for i in range(nc):
        if drops[colors[i]][good] != []:
          h,b = np.histogram(drops[colors[i]][good],60)
          h = np.insert(h,[0,len(h)],[0,0])                 # Pad with zeros
          b = np.insert(b,[0,len(b)-1],[2*b[0]-b[1],b[-1]]) # Pad with zeros
          h = np.sqrt(h) # Sqrt better represents small values
          drops['hists'].append(h)
          drops['bins'].append(b)

          b = drops['bins'][i][:-1]
          di = drops[colors[i]][good]

          # Default threshold is 40% from bottom to top
          drops['color_thresh'][i] = SCATTER_THRESH*np.max(di)+(1-SCATTER_THRESH)*np.min(di)

          # If a lower cluster is found, set thresh at FHWM + 2 bins
          mnpk = np.argmax(np.multiply(h,b<drops['color_thresh'][i]))
          fwhm = np.where((b>b[mnpk]) & (h<h[mnpk]/2))[0]
          if (fwhm.size>0) and (fwhm[0]-mnpk<10):
            drops['color_thresh'][i] = b[fwhm[0]+2]
        else:
          drops = {}
          break

    return drops
    
###############################################################################
def plot_figures(imgs,drops):
    ''' 
    Plots masked fluorescent images (where there are drops) and 2D scatters of Diameter/fluorescent combinations.
    
    Parameters:
    -----------
    imgs: dictionary
        Collection of each fluorescent/BF image as items with keys from VALID_COLORS
        
    drops: dictionary
        Collection of 1D arrays (each length N, where N is # of drops) associated with drop metrics.
        BF, DAPI, GFP, RFP, CY5 - mean image value inside drop (RFU)
        Diameter  - Diameter in microns
        perimeter - Perimenter in microns
        good      - Boolean, whether the drop is large and round enough
        Radius    - Diameter in pixels
        X         - X Center, in pixels
        Y         - Y Center, in pixels

        1D array of with one element per color
        color_thresh - Fluorescent/diameter threshold per color
    '''

    global MIN_DIAM, MIN_DIAM_PERIM

    # Organize channels
    colors = drops['colors']
    nc = len(colors) # Number of colors
    nx  = nc*(nc-1)+1 # Number of color combinations

    # Screen colors associated with channels (0=Red, 1=Green, 2=Blue, -1= BW)
    chancol = {'CY5':0, 'RFP':0, 'GFP':1,'DAPI':2,'Diameter':-1}
    
    good = drops['good']

    ### Plot BF/fluorescent images
    plt.figure(figsize=(nx*8,15))
    for i in range(nc):
        plt.subplot(2,nc+1,i+1)
       
        # Generate color-scheme for image
        vals = np.ones((256, 4))
        for j in range(3):
            vals[:, j] = np.linspace(0, chancol[colors[i]] in [-1,j], 256)
            
        # Plot each image
        if colors[i]=='Diameter':
            plt.imshow(imgs['BF'],cmap=ListedColormap(vals))
            drops_show = good
            outline_color = 'r'
        else:
            plt.imshow(np.multiply(imgs[colors[i]],imgs['BW']),cmap=ListedColormap(vals)) # Mask fluorescence by BW
            di = drops[colors[i]]
            drops_show = good & (di>drops['color_thresh'][i])
            outline_color = np.isin([0,1,2],chancol[colors[i]],invert=True)
        
        # Draw drop outlines on image
        th = np.arange(0,2*3.141593,3.141593/20)
        _,XX = np.meshgrid(th,drops['X'][drops_show])
        _,YY = np.meshgrid(th,drops['Y'][drops_show])
        TH,RR = np.meshgrid(th,drops['Radius'][drops_show]+10)

        plt.scatter(x=XX+np.multiply(np.cos(TH),RR),y=YY+np.multiply(np.sin(TH),RR),color=outline_color,s=.5)

        plt.xticks([])
        plt.yticks([])
        plt.xlim([0, imgs['BW'].shape[1]])
        plt.ylim([0, imgs['BW'].shape[0]])
        plt.title(colors[i] + ' (Masked)' if colors[i]!='Diameter' else 'BF',fontsize=20)
        
    # Plot merged image if it exists
    if 'RGB' in imgs.keys():
        plt.subplot(1,nc+1,nc+1)
        plt.imshow(np.multiply(imgs['RGB'],imgs['BW'][:,:,None]))
        plt.xticks([])
        plt.yticks([])
        plt.title('RGB (Masked)',fontsize=20)
        
    ### Plot scatters combinations
    cnt = 1         # Combination iteration count

    # Debugging figure. See what drops it finds
    plt.subplot(2,nx,nx+cnt)
    plt.loglog(drops['Diameter']+.05,np.divide(drops['Diameter'],drops['perimeter']+20),'.',markersize=1)
    plt.plot(plt.xlim(),[MIN_DIAM_PERIM,MIN_DIAM_PERIM],'k--')
    plt.plot([MIN_DIAM,MIN_DIAM],plt.ylim(),'k--')
    plt.text(plt.xlim()[0]*1.5,(MIN_DIAM_PERIM+plt.ylim()[0])/2,'Small, Not Round\n(BAD)',color=[1,0,0],va='center',ha='left')
    plt.text(plt.xlim()[1]/1.5,(MIN_DIAM_PERIM+plt.ylim()[0])/2,'Large, Not Round\n(BAD)',color=[1,0,0],va='center',ha='right')
    plt.text(plt.xlim()[0]*1.5,(MIN_DIAM_PERIM+plt.ylim()[1])/2,'Small, Round\n(BAD)',color=[1,0,0],va='center',ha='left')
    plt.text(plt.xlim()[1]/1.5,(MIN_DIAM_PERIM+plt.ylim()[1])/2,'Large, Round\n(GOOD)',color=[0,.5,0],va='center',ha='right')
    plt.xlabel('Diameter (um)')
    plt.ylabel('Roundness (Diameter/Perimeter)')
    plt.title('Roundness vs Diameter')
    cnt +=1

    # Iterate through each pair of BF/fluorescences
    for i in range(nc):
        for j in range(i+1,nc):
            
            # Collect coordinates
            di = drops[colors[i]][good]
            dj = drops[colors[j]][good]
            
            # Find quadrant thresholds
            yth = drops['color_thresh'][j] if colors[j]!='Diameter' else 76
            xth = drops['color_thresh'][i] if colors[i]!='Diameter' else 76 # Diameter threshold is 76um
            
            # Scatter colors
            col = np.ones((4,3))*.2
            for k in range(2):
                ind = [i,j][k] if colors[i]=='Diameter' else [j,i][k]
                if chancol[colors[ind]]>=0:
                    col[[k+1,3],chancol[colors[ind]]] = [.65,.9]
                    
            # Plot scatters
            plt.subplot(2,nx,nx+cnt)
            plt.scatter(di,dj,s=2,c=col[(dj>yth)+2*(di>xth),:])
            plt.xlabel(colors[i]+' (RFU)' if colors[i]!='Diameter' else 'Diameter (um)',fontsize=14)
            plt.ylabel(colors[j]+' (RFU)' if colors[j]!='Diameter' else 'Diameter (um)',fontsize=14)
            plt.title(colors[j]+' vs '+colors[i],fontsize=16)
            
            # Plot four-quadrant (or upper/lower) counts on scatters
            for m in range(2):
                mm = dj*(m-.5)<=yth*(m-.5)
                if colors[i]!='Diameter':
                    for k in range(2):
                        kk = di*(k-.5)<=xth*(k-.5)
                        if np.sum(kk&mm)>0:
                            plt.text(np.quantile(di[kk & mm],.8),np.quantile(dj[kk & mm],.8),str(np.sum([kk&mm])),fontsize=16)
                else:
                    if np.sum(mm)>0:
                        plt.text(np.quantile(di,.8),np.quantile(dj[mm],.8),str(np.sum([mm])),fontsize=16)
            
            # Plot x histogram
            bins = drops['bins']
            hists = drops['hists']
            xlim = plt.xlim()
            plt.plot((hists[j]/np.max(hists[j]))*np.diff(xlim)*.15+xlim[0],bins[j][:-1],'k')
            plt.xlim(xlim)

            # Plot y histogram
            ylim = plt.ylim()
            ylim = [ylim[0]-np.diff(ylim)*.2,ylim[1]]
            plt.plot(bins[i][:-1],hists[i]/np.max(hists[i])*np.diff(ylim)*.15+ylim[0],'k')
            plt.ylim(ylim)
            plt.plot(plt.xlim(),[yth,yth],'k--')

            if colors[i]!='Diameter':

                prcnt_above_right = 100.0*np.sum((di>xth) & (dj>yth))/len(dj)
                prcnt_above = 100.0*np.sum(dj>yth)/len(dj)
                prcnt_right = 100.0*np.sum(di>xth)/len(dj)
                plt.text(np.mean(plt.xlim()),plt.ylim()[1],'Above (%3.1f%%), Right (%3.1f%%), Above+Right (%3.1f%%)'%
                          (prcnt_above,
                          prcnt_right,
                          prcnt_above_right),va='top',ha='center',fontsize=12)
                plt.plot([xth,xth],plt.ylim(),'k--')

            else:
                diameter_prcnt_above = 100.0*np.sum(dj>yth)/len(dj)
                plt.text(np.mean(plt.xlim()),plt.ylim()[1],'Above (%3.1f%%)'%
                          (diameter_prcnt_above),va='top',ha='center',fontsize=12)

            cnt += 1
    plt.show()

###############################################################################
def bead_metrics(drops, Output_Folder):

    ''' 
    Return DataFrame 'metrics' with drop readouts
    
    Parameters:
    -----------
    drops: dictionary
        Collection of 1D arrays (each length N, where N is # of drops) associated with drop metrics.
        BF, DAPI, GFP, RFP, CY5 - mean image value inside drop (RFU)
        Diameter  - Diameter in microns
        perimeter - Perimenter in microns
        good      - Boolean, whether the drop is large and round enough

    Returns:
    -----------
    metrics: DataFrame
        Single index, multicolumn DataFrame, containing metrics for image set
        Fraction of drops above fluorescence threshold for each channel
        Median drop diameter
        Area of drop above 
    '''

    global SCATTER_THRESH

    # Organize channels
    colors = np.sort(list(drops.keys()))
    colors = np.insert(colors[colors!='Diameter'],0,'Diameter')
    colors = [c for c in colors if c in ['DAPI','GFP','RFP','CY5','Diameter']]
    nc = len(colors)

    metrics = pd.DataFrame()
    good = drops['good']

    colors = drops['colors']   
    nc = len(colors) # Number of colors
    one_sample = 1
    if nc == 1:
      one_sample = -1

    for i in range(nc):
        for j in range(i+one_sample,nc):
          good = drops['good']
          di = drops[colors[i]][good]
          dj = drops[colors[j]][good]
          # Find quadrant thresholds
          yth = drops['color_thresh'][j] if colors[j]!='Diameter' else 76
          xth = drops['color_thresh'][i] if colors[i]!='Diameter' else 76 # Diameter threshold is 76um
          
          if Analysis_Type == "BEADS_INDV":
            metrics["Individual "+ str(colors[i])] = di
            metrics["Individual "+ str(colors[j])] = dj
    
    # Iterate through channels
    for i in range(nc):
        d = drops[colors[i]][good]
        if Analysis_Type == "BEADS":
          metrics[colors[i]+'+'] = [np.sum((d>drops['color_thresh'][i]))/len(d)]
          metrics[colors[i]+'+ Count'] = [np.sum((d>drops['color_thresh'][i]))]

    # Calculate non-fluorescent metrics
    drop_count = np.sum(good)
    if Analysis_Type == "BEADS":
      metrics['Bead_Count'] = drop_count

    prcnt_above_right = np.sum((di>xth) & (dj>yth))/len(dj)
    prcnt_above = np.sum(dj>yth)/len(dj)
    prcnt_right = np.sum(di>xth)/len(dj)
    prcnt_none = prcnt_above_right + prcnt_above + prcnt_right

    if drop_count > (drop_count * prcnt_none):
      if Analysis_Type == "BEADS":
        metrics['None'] = drop_count - (drop_count * prcnt_none)
    else:
      if Analysis_Type == "BEADS":
        metrics['None'] = 0
    diam = drops['Diameter'][good]
    med = np.median(diam)
    
    if Analysis_Type == "BEADS":
      metrics["green"] = drop_count * prcnt_above
      metrics["red"] = drop_count * prcnt_right
      metrics["mixed"] = drop_count * prcnt_above_right
      metrics['MedBeadDiam'] = med
      metrics['Area>2XMed'] = np.sum(np.square(diam[np.square(diam)>2*med**2]))/np.sum(np.square(diam))
      metrics['Path'] = Output_Folder

    return(metrics)

###############################################################################
def Flourecence_Image_Reader(dire):
  uploaded = []
  return_list = []
  uploaded,filenames = all_imgs_directory(dire)
  filenames = [filename.replace(dire + '/', '') for filename in filenames]
  
  #format: [[set_identity, [[img1,color,name],[img2,color,name],[img3,color,name]]], [img_identity, [[img1,color,name],[img2,color,name],[img3,color,name]]]]
  identifier_and_images = []
  
  if filenames:
    print(filenames)

    image_iter_folder = 0
    for key in uploaded:
      if key == None:
        break
      img = np.asarray(key)  
      #####################
      #Algorithm: Image Set Generation
      #1.What color?
      color = Color_Detection(img)

      #Example image names, number is the color (d4 is normally brightfield)
      #Lubna-cy5_Slide 4_D_p00_0_A01f00d3
      #Lubna-cy5_Slide 4_D_p00_0_A01f00d4
      #Lubna-cy5_Slide 4_D_p00_0_A01f01d3
      #Lubna-cy5_Slide 4_D_p00_0_A01f01d4
      #2. What's its name?
      j = 0
      image_name = filenames[image_iter_folder].replace(dire, '')
      reversed_name = image_name[::-1]
      for letter in reversed_name:
        if letter == ' ' or letter == '_' or letter == '-':
          break      
        j += 1
      img_identity = reversed_name[5:j]

      #3. Do I have this in my list of sets?
      found_identity = False
      k = 0
      for img_set in identifier_and_images:
        if img_identity == img_set[0]:
          identifier_and_images[k][1].append([img,color,image_name])
          found_identity = True
        k+=1

      #4. I didn't find it in the set so make a new one
      if found_identity == False:
        identifier_and_images.append([img_identity,[[img,color,image_name]]])

      image_iter_folder += 1
  
  return identifier_and_images


######################################################################################
def Read_Decide_Analyze(identifier_and_images,Directory):

  final_data = pd.DataFrame()
  name_images = []
 # what type of image set is this? Then run analysis
  for image_set in identifier_and_images:
    print("\n\n#############################")
    #reverse back for human readability
    name = image_set[0][::-1]
    number_pictures = len(image_set[1])
    name_Mixed = None
    if number_pictures <= 4:
      empty_array = np.zeros((1,1))
      img_set = [empty_array,empty_array,empty_array,empty_array]
      
      for i in range(len(image_set[1])):
        color = image_set[1][i][1]
        image = image_set[1][i][0]
        
        if color == "grey":
          name_BF = image_set[1][i][2]
          img_set[0] = image

        elif color == "red":
          name_CY5 = image_set[1][i][2]
          img_set[1] = image

        elif color == "blue": 
          name_DAPI = image_set[1][i][2]
          img_set[2] = image

        elif color == "green":
          name_GFP = image_set[1][i][2]
          img_set[3] = image

        elif color == "bf_mixed":
          name_Mixed = image_set[1][i][2]

      if img_set[0].any() and img_set[1].any() and img_set[3].any(): 
        print("Set BW_R_G: " + str(name))
        imgs = load_images(dirpath = Directory+'/',BF = name_BF, GFP = name_GFP, CY5 = name_CY5)

      elif img_set[0].any() and img_set[3].any(): 
        print("Set BW_G: " + str(name))
        imgs = load_images(dirpath = Directory+'/',BF = name_BF, GFP = name_GFP)

      elif img_set[0].any() and img_set[1].any(): 
        print("Set BW_R: " + str(name))
        imgs = load_images(dirpath = Directory+'/',BF = name_BF, CY5 = name_CY5)

      elif img_set[0].any(): 
        print("Set BW: " + str(name))
        imgs = load_images(dirpath = Directory+'/',BF = name_BF)
        
      invert = True
      imgs_copy = imgs.copy()
      drops = find_drops(imgs, invert)  
      if drops == {}:
        invert = False
        drops = find_drops(imgs_copy, invert)
      if drops != {}: 
        final_data = final_data.append(bead_metrics(drops,Output_Folder), ignore_index=True)
        name_images.append(name)
        if Output_Browser:
          plot_figures(imgs,drops)
      else:
        print("Poor Image Rejected: " + name)
    else:
      print("more images than expected in category: " + name)
  if Output_Folder:
    filename = Output_Folder + "/"+ str(Date) + "_" + Run_ID + "_"

    if Running_On_Mac:
      final_data.to_csv(filename + '.csv')
    else:
      final_data.to_csv("/content/drive/" + filename + '.csv')

  try:
    print("\n\n\n#####################################")
    print("SUMMARY:")
    print("\nMedian")
    print(final_data["Individual Diameter"].median())
    print("\nMode")
    print(final_data["Individual Diameter"].mode())
    print("\n%CV")
    print(variation(final_data["Individual Diameter"]))
    print("\nSummary")
    print(final_data.describe())
    final_data["Individual Diameter"].plot.density()
    plt.title('Size')
  except:
    print("Poor quality images")
#  return return_data

#@title RUN / MAIN

# Mostly Error Checking
# Determines what the folder is and what action to use for it
# Collects all data from both types of runs and formats and creates a output
###############################################################################

print("\n\n########################################################\n\n")
print("\n\n##############  YOU ARE RUNNING " + Analysis_Type + " ANALYSIS  ##############\n\n")
print("\n\n########################################################\n\n\n\n\n")

CSV_Data = [[Name,Date,Run_ID,Analysis_Type]]
data = None
if Analysis_Type == 'BRIGHTFIELD':
    CSV_Data.append(['Image Name', 'Image Location', 'Processed Image Location','Analysis Type', 'Med area', 'Area STD', '#>2x Med', 'Area>2x Med', "Total Area", "Emulsion Stability",'', '', 'Total Drops', '%Bead Loading', 'Number Beads', "Number NoBeads"])
elif Analysis_Type == 'FLOURESCENCE':
    CSV_Data.append(['Image Name',"r_intensity_list","g_intensity_list","b_intensity_list","rb_intensity_list","rg_intensity_list","bg_intensity_list"])

for dire in directories:
  print("##################################################################################################\nNEXT FOLDER\n")

  if Analysis_Type == "BEADS" or Analysis_Type == "BEADS_INDV":
    data = Beads_Controller(dire)
    if data:
      for image_data in data:
        CSV_Data.append(image_data)
    print("Folder" + str(dire) +  "    \n\nFINSIHED\n\n\n")


#write the collected Data
#################################################
if Output_Folder and Analysis_Type is not 'H5_CSV' and data is not None:
  Write_CSV(CSV_Data,custom_name=None)

